from pyine.indicators import *



# //You Agree: You have been granted a personal license to this indicator. You CAN NOT share the source code or resell the indicator source code in any way. Legal action will be taken if these terms are broken.

def Approximation1(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation1 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation2(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation2 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation3(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation3 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation4(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation4 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation5(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation5 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation6(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation6 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation7(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation7 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation8(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation8 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation9(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation9 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation10(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation10 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation11(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation11 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation12(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation12 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation13(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation13 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation14(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation14 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation15(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation15 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation16(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation16 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation17(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation17 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


def Approximation18(a, b):
    l0 = 0.0
    l1 = 0.0
    l2 = 0.0
    l3 = 0.0
    l0 = (1 - b) * a + b * nz(l0[1])
    l1 = -b * l0 + nz(l0[1]) + b * nz(l1[1])
    l2 = -b * l1 + nz(l1[1]) + b * nz(l2[1])
    l3 = -b * l2 + nz(l2[1]) + b * nz(l3[1])
    Approximation18 = (l0 + 2 * l1 + 2 * l2 + l3) / 6


Conjecture1 = Approximation1(open, 0.1)
Conjecture2 = Approximation2(open, 0.15)
Conjecture3 = Approximation3(open, 0.2)
Conjecture4 = Approximation4(open, 0.25)
Conjecture5 = Approximation5(open, 0.3)
Conjecture6 = Approximation6(open, 0.35)
Conjecture7 = Approximation7(open, 0.4)
Conjecture8 = Approximation8(open, 0.45)
Conjecture9 = Approximation9(open, 0.5)
Conjecture10 = Approximation10(open, 0.55)
Conjecture11 = Approximation11(open, 0.6)
Conjecture12 = Approximation12(open, 0.65)
Conjecture13 = Approximation13(open, 0.7)
Conjecture14 = Approximation14(open, 0.75)
Conjecture15 = Approximation15(open, 0.8)
Conjecture16 = Approximation16(open, 0.85)
Conjecture17 = Approximation17(open, 0.9)
Conjecture18 = Approximation18(open, 0.95)

Inapproximability = (Approximation1(ta.tr, 0.1) + Approximation2(ta.tr, 0.15) + Approximation3(ta.tr,
                                                                                               0.2) + Approximation4(
    ta.tr, 0.25) + Approximation5(ta.tr, 0.3) + Approximation6(ta.tr, 0.35) + Approximation7(ta.tr,
                                                                                             0.4) + Approximation8(
    ta.tr, 0.45) + Approximation9(ta.tr, 0.5) + Approximation10(ta.tr, 0.55) + Approximation11(ta.tr,
                                                                                               0.6) + Approximation12(
    ta.tr, 0.65) + Approximation13(ta.tr, 0.7) + Approximation14(ta.tr, 0.75) + Approximation15(ta.tr,
                                                                                                0.8) + Approximation16(
    ta.tr, 0.85) + Approximation17(ta.tr, 0.9) + Approximation18(ta.tr, 0.95)) / 18
amlag = (
                    Conjecture1 + Conjecture2 + Conjecture3 + Conjecture4 + Conjecture5 + Conjecture6 + Conjecture7 + Conjecture8 + Conjecture9 + Conjecture10 + Conjecture11 + Conjecture12 + Conjecture13 + Conjecture14 + Conjecture15 + Conjecture16 + Conjecture17 + Conjecture18) / 18

Upper_Threshold_of_Approximability1 = amlag + Inapproximability * 1.618
Upper_Threshold_of_Approximability2 = amlag + 2 * Inapproximability * 1.618
Lower_Threshold_of_Approximability1 = amlag - Inapproximability * 1.618
Lower_Threshold_of_Approximability2 = amlag - 2 * Inapproximability * 1.618

bcolor =  # 008080

lower_color = lambda ta.ema(close, 40) - ta.ema(high - low,
                                                40) * 4 < Lower_Threshold_of_Approximability2,  # 0f790f, #0f790f
:  # 0f790f if ta.ema(close,40)-ta.ema(high-low,40)*4<Lower_Threshold_of_Approximability2 else #0f790f :
upper_color = lambda ta.ema(close, 40) + ta.ema(high - low,
                                                40) * 4 > Upper_Threshold_of_Approximability2,  # aa1d1d, #aa1d1d
:  # aa1d1d if ta.ema(close,40)+ta.ema(high-low,40)*4>Upper_Threshold_of_Approximability2 else #aa1d1d :
# hplot2 = plot(Upper_Threshold_of_Approximability2,   color=upper_color, linewidth=1, title="Upper Band")
# alplot = plot(amlag, color=color.new(bcolor,50), linewidth=1, title="Middle Band")
# lplot2 = plot(Lower_Threshold_of_Approximability2,   color=lower_color, linewidth=1, title="Lower Band")
# crossdn = high < Upper_Threshold_of_Approximability2[1] and high[1] >= Upper_Threshold_of_Approximability2[1]//and open < open[1]
# crossup = low > Lower_Threshold_of_Approximability2[1] and low[1] <= Lower_Threshold_of_Approximability2[1]//and open > open[1]
u_color = lambda Upper_Threshold_of_Approximability2 > ta.ema(close, 40) + ta.ema(high - low, 40) * 4,  # aa1d1d, na
:  # aa1d1d if Upper_Threshold_of_Approximability2>ta.ema(close,40)+ta.ema(high-low,40)*4 else na :
l_color = lambda Lower_Threshold_of_Approximability2 < ta.ema(close, 40) - ta.ema(high - low, 40) * 4,  # 0f790f, na
:  # 0f790f if Lower_Threshold_of_Approximability2<ta.ema(close,40)-ta.ema(high-low,40)*4 else na :


# u = plot(ta.ema(close, 40) + ta.ema(high - low, 40) * 4, color=u_color, title="Upper Margin")
# l = plot(ta.ema(close, 40) - ta.ema(high - low, 40) * 4, color=l_color, title="Lower Margin")
# fill(u, hplot2, color=Upper_Threshold_of_Approximability2 > ta.ema(close, 40) + ta.ema(high - low, 40) * 4 ? color.new(#ff0000, 50):na)
# fill(l, lplot2, color=Lower_Threshold_of_Approximability2 < ta.ema(close, 40) - ta.ema(high - low, 40) * 4 ? color.new(#0f790f,50):na)


p_display = True
label_direction = True
w_adjust = input(1, 'Buy Limit/Take Profit Line Width')

updown = lambda label_direction, label.style_label_down, label.style_label_up
: label.style_label_down if label_direction else label.style_label_up:
down = lambda label_direction, label.style_label_up, label.style_label_down
: label.style_label_up if label_direction else label.style_label_down:

away = input(20, 'Label Distance')
dp = input.int(2, 'Decimal Places', minval=0, step=1)

# //Indicator Parameters
liveprice = close
show_selllimitone = True
show_takeprofit = input(True, 'Show Take Profit')
show_marketorder = input(True, 'Show Market Order')
show_buylimit1 = input(True, 'Show Buy Limit 1')
show_buylimit2 = input(True, 'Show Buy Limit 2')
show_buylimit3 = input(True, 'Show Buy Limit 3')

# //Buy/Take Profit Color
TPC = color.green
BLC = color.gray

slp1 = input.float(1.04, title='Take Profit % (Default 4%)', step=0.01)
tpl_display = True
slp = True

blp1 = 1
blp2 = 1
blp3 = 0.77
blp4 = 0.55
blp5 = 0.27

bep1 = 0.906
bep2 = 0.807
bep3 = 0.712
bep4 = 0.624

long_tp = liveprice * slp1
long_bl1 = liveprice * blp1
long_bl2 = liveprice * blp2
long_bl3 = liveprice * blp3
long_bl4 = liveprice * blp4
long_bl5 = liveprice * blp5
long_be1 = liveprice * bep1
long_be2 = liveprice * bep2
long_be3 = liveprice * bep3
long_be4 = liveprice * bep4

# //Buy Limits

if show_marketorder:
    bl2 = line.new(bar_index, long_bl2, bar_index + away + 100, long_bl2, color=BLC, width=w_adjust)
    line.delete(bl2[1])

if show_buylimit1:
    bl3 = line.new(bar_index, long_bl3, bar_index + away + 100, long_bl3, color=BLC, width=w_adjust)
    line.delete(bl3[1])

if show_buylimit2:
    bl4 = line.new(bar_index, long_bl4, bar_index + away + 100, long_bl4, color=BLC, width=w_adjust)
    line.delete(bl4[1])

if show_buylimit3:
    bl5 = line.new(bar_index, long_bl5, bar_index + away + 100, long_bl5, color=BLC, width=w_adjust)
    line.delete(bl5[1])

# //Sell Limits

if show_takeprofit:
    lt = line.new(bar_index, long_tp, bar_index + away + 100, long_tp, color=TPC, width=w_adjust)
    line.delete(lt[1])

if barstate.islast:
    p1 = lambda slp, long_tp, blp4
: long_tp if slp else blp4:
p2 = lambda slp, long_bl1, blp4
: long_bl1 if slp else blp4:
p3 = lambda slp, long_bl1, blp4
: long_bl1 if slp else blp4:
p4 = lambda slp, long_bl2, blp4
: long_bl2 if slp else blp4:
p5 = lambda slp, long_bl3, blp4
: long_bl3 if slp else blp4:
p6 = lambda slp, long_bl4, blp4
: long_bl4 if slp else blp4:
p7 = lambda slp, long_bl5, blp4
: long_bl5 if slp else blp4:

p1t = str.tostring(math.round(p1, dp))
ln = 0
ln = str.length(p1t) - str.length(str.tostring(int(p1)))
if ln == 0:
    p1t += "."
while ln < dp + 1
    p1t += '0'
    ln = str.length(p1t) - str.length(str.tostring(int(p1)))

p2t = str.tostring(math.round(p2, dp))
ln = str.length(p2t) - str.length(str.tostring(int(p2)))
if ln == 0:
    p2t += "."
while ln < dp + 1
    p2t += '0'
    ln = str.length(p2t) - str.length(str.tostring(int(p2)))

p3t = str.tostring(math.round(p3, dp))
ln = str.length(p3t) - str.length(str.tostring(int(p3)))
if ln == 0:
    p3t += "."
while ln < dp + 1
    p3t += '0'
    ln = str.length(p3t) - str.length(str.tostring(int(p3)))

p4t = str.tostring(math.round(p4, dp))
ln = str.length(p4t) - str.length(str.tostring(int(p4)))
if ln == 0:
    p4t += "."
while ln < dp + 1
    p4t += '0'
    ln = str.length(p4t) - str.length(str.tostring(int(p4)))

p5t = str.tostring(math.round(p5, dp))
ln = str.length(p5t) - str.length(str.tostring(int(p5)))
if ln == 0:
    p5t += "."
while ln < dp + 1
    p5t += '0'
    ln = str.length(p5t) - str.length(str.tostring(int(p5)))

p6t = str.tostring(math.round(p6, dp))
ln = str.length(p6t) - str.length(str.tostring(int(p6)))
if ln == 0:
    p6t += "."
while ln < dp + 1
    p6t += '0'
    ln = str.length(p6t) - str.length(str.tostring(int(p6)))

p7t = str.tostring(math.round(p7, dp))
ln = str.length(p7t) - str.length(str.tostring(int(p7)))
if ln == 0:
    p7t += "."
while ln < dp + 1
    p7t += '0'
    ln = str.length(p7t) - str.length(str.tostring(int(p7)))

ValueOne = (2)
Input = input.int(10, title='Signal Strength')


def lele(qual, len):
    bindex = 0.0
    sindex = 0.0
    bindex = nz(bindex[1], 0)
    sindex = nz(sindex[1], 0)
    ret = 0
    if (close > close[4]):
        bindex = bindex + 1
    if (close < close[4])
        sindex = sindex + 1
    if (bindex > qual) and (close < open) and high >= ta.highest(high, len):
        bindex = 0
        ret = -1
    if ((sindex > qual) and (close > open) and (low <= ta.lowest(low, len))):
        sindex = 0
        ret = 1
    ret


major = lele(ValueOne, Input)
major_bearish_reversal = lambda -1, high, na)
: high if -1 else na):
major_bullish_reversal = lambda 1, low, na)
: low if 1 else na):


# //SIGNALS//

varip
bool
REPAINT_MAJ_BUR = False
if barstate.isnew:
    REPAINT_MAJ_BUR = False
if major_bullish_reversal:
    REPAINT_MAJ_BUR = True
MAJ_BUR_NO_REPAINT = barstate.isconfirmed

# //Major Buy and Sell
# plotshape(major_bullish_reversal  and MAJ_BUR_NO_REPAINT, title="Buy", color=#098209, location=location.belowbar , style=shape.labelup, textcolor=color.white, text="Buy", size=size.tiny, offset=0)

varip
bool
REPAINT_MAJ_BER = False
if barstate.isnew:
    REPAINT_MAJ_BER = False
if major_bearish_reversal:
    REPAINT_MAJ_BER = True
MAJ_BER_NO_REPAINT = barstate.isconfirmed

# plotshape(major_bearish_reversal and MAJ_BER_NO_REPAINT, title="Sell", color=#ea0d0d, location=location.abovebar , style=shape.labeldown, textcolor=color.white, text="Sell", size=size.tiny, offset=0)

# //Strong Buy and Sell//

varip
bool
REPAINT_LTA = False
if barstate.isnew:
    REPAINT_LTA = False
if Lower_Threshold_of_Approximability2:
    REPAINT_LTA = True
LTA_NO_REPAINT = barstate.isconfirmed

# plotshape(crossup ? Lower_Threshold_of_Approximability2 and LTA_NO_REPAINT : na, location=location.belowbar, style=shape.labelup, color=#3a17b8, size=size.tiny, text="Strong \n Buy", textcolor=color.white, offset=0)

varip
bool
REPAINT_UTA = False
if barstate.isnew:
    REPAINT_UTA = False
if Upper_Threshold_of_Approximability2:
    REPAINT_UTA = True
UTA_NO_REPAINT = barstate.isconfirmed

# plotshape(crossdn ? Upper_Threshold_of_Approximability2 and UTA_NO_REPAINT : na, location=location.abovebar, style=shape.labeldown, color=#3a17b8, size=size.tiny, text="Strong \n Sell", textcolor=color.white, offset=0)


# //ALERTS//

# //Major Buy and Sell

varip
bool
REPAINT_MAJ_BUL_ALERT = False
if barstate.isnew:
    REPAINT_MAJ_BUL_ALERT = False
if major_bullish_reversal:
    REPAINT_MAJ_BUL_ALERT = True
MAJ_BUL_ALERT_NO_REPAINT = barstate.isconfirmed

alertcondition(major_bullish_reversal and MAJ_BUL_ALERT_NO_REPAINT, title='Buy', message='Buy Signal')

varip
bool
REPAINT_MAJ_BER_ALERT = False
if barstate.isnew:
    REPAINT_MAJ_BER_ALERT = False
if major_bearish_reversal:
    REPAINT_MAJ_BER_ALERT = True
MAJ_BER_ALERT_NO_REPAINT = barstate.isconfirmed

alertcondition(major_bearish_reversal and MAJ_BER_ALERT_NO_REPAINT, title='Sell', message='Sell Signal')

# //Strong Buy and Sell

varip
bool
REPAINT_LTA_ALERT = False
if barstate.isnew:
    REPAINT_LTA_ALERT = False
if Lower_Threshold_of_Approximability2:
    REPAINT_LTA_ALERT = True
REPAINT_LTA_ALERT_NO_REPAINT = barstate.isconfirmed

failed
to
interpret
line, make
sure
it is formatted as:  na = b ? c: d
varip
bool
REPAINT_UTA_ALERT = False
if barstate.isnew:
    REPAINT_UTA_ALERT = False
if Upper_Threshold_of_Approximability2:
    REPAINT_UTA_ALERT = True
UTA_ALERT_NO_REPAINT = barstate.isconfirmed

failed
to
interpret
line, make
sure
it is formatted as:  na = b ? c: d